"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toBackend = exports.resolveBackend = exports.of = exports.empty = void 0;
const backend = require("./backend");
const proto = require("../../gcp/proto");
const api = require("../../.../../api");
const params = require("./params");
const previews_1 = require("../../previews");
const error_1 = require("../../error");
const functional_1 = require("../../functional");
function empty() {
    return {
        requiredAPIs: [],
        endpoints: {},
        params: [],
    };
}
exports.empty = empty;
function of(endpoints) {
    const build = empty();
    build.endpoints = endpoints;
    return build;
}
exports.of = of;
function isMemoryOption(value) {
    return value == null || [128, 256, 512, 1024, 2048, 4096, 8192].includes(value);
}
async function resolveBackend(build, userEnvOpt, userEnvs) {
    const projectId = userEnvOpt.projectId;
    let paramValues = {};
    if (previews_1.previews.functionsparams) {
        paramValues = await params.resolveParams(build.params, projectId, userEnvs);
    }
    return toBackend(build, paramValues);
}
exports.resolveBackend = resolveBackend;
function toBackend(build, paramValues) {
    const bkEndpoints = [];
    for (const endpointId of Object.keys(build.endpoints)) {
        const bdEndpoint = build.endpoints[endpointId];
        let regions = bdEndpoint.region;
        if (typeof regions === "undefined") {
            regions = [api.functionsDefaultRegion];
        }
        for (const region of regions) {
            const trigger = discoverTrigger(bdEndpoint, paramValues);
            if (typeof bdEndpoint.platform === "undefined") {
                throw new error_1.FirebaseError("platform can't be undefined");
            }
            if (!isMemoryOption(bdEndpoint.availableMemoryMb)) {
                throw new error_1.FirebaseError("available memory must be a supported value, if present");
            }
            let timeout;
            if (bdEndpoint.timeoutSeconds) {
                timeout = params.resolveInt(bdEndpoint.timeoutSeconds, paramValues);
            }
            else {
                timeout = 60;
            }
            const bkEndpoint = Object.assign({ id: endpointId, project: bdEndpoint.project, region: region, entryPoint: bdEndpoint.entryPoint, platform: bdEndpoint.platform, runtime: bdEndpoint.runtime, timeoutSeconds: timeout }, trigger);
            proto.renameIfPresent(bkEndpoint, bdEndpoint, "maxInstances", "maxInstances", (from) => {
                return params.resolveInt(from, paramValues);
            });
            proto.renameIfPresent(bkEndpoint, bdEndpoint, "minInstances", "minInstances", (from) => {
                return params.resolveInt(from, paramValues);
            });
            proto.renameIfPresent(bkEndpoint, bdEndpoint, "concurrency", "concurrency", (from) => {
                return params.resolveInt(from, paramValues);
            });
            proto.copyIfPresent(bkEndpoint, bdEndpoint, "ingressSettings", "availableMemoryMb", "environmentVariables", "labels");
            proto.copyIfPresent(bkEndpoint, bdEndpoint, "secretEnvironmentVariables");
            if (bdEndpoint.vpc) {
                bkEndpoint.vpc = { connector: params.resolveString(bdEndpoint.vpc.connector, paramValues) };
                proto.copyIfPresent(bkEndpoint.vpc, bdEndpoint.vpc, "egressSettings");
            }
            proto.renameIfPresent(bkEndpoint, bdEndpoint, "serviceAccountEmail", "serviceAccount");
            if ("serviceAccountEmail" in bkEndpoint && !bdEndpoint.serviceAccount) {
                delete bkEndpoint.serviceAccountEmail;
            }
            bkEndpoints.push(bkEndpoint);
        }
    }
    const bkend = backend.of(...bkEndpoints);
    bkend.requiredAPIs = build.requiredAPIs;
    return bkend;
}
exports.toBackend = toBackend;
function discoverTrigger(endpoint, paramValues) {
    const resolveInt = (from) => params.resolveInt(from, paramValues);
    const resolveString = (from) => params.resolveString(from, paramValues);
    const resolveBoolean = (from) => params.resolveBoolean(from, paramValues);
    let trigger;
    if ("httpsTrigger" in endpoint) {
        const bkHttps = {};
        if (endpoint.httpsTrigger.invoker) {
            bkHttps.invoker = [endpoint.httpsTrigger.invoker];
        }
        trigger = { httpsTrigger: bkHttps };
    }
    else if ("callableTrigger" in endpoint) {
        trigger = { callableTrigger: {} };
    }
    else if ("blockingTrigger" in endpoint) {
        trigger = { blockingTrigger: endpoint.blockingTrigger };
    }
    else if ("eventTrigger" in endpoint) {
        const bkEventFilters = {};
        for (const [key, value] of Object.entries(endpoint.eventTrigger.eventFilters)) {
            bkEventFilters[key] = params.resolveString(value, paramValues);
        }
        const bkEvent = {
            eventType: endpoint.eventTrigger.eventType,
            eventFilters: bkEventFilters,
            retry: resolveBoolean(endpoint.eventTrigger.retry || false),
        };
        if (endpoint.eventTrigger.serviceAccount) {
            bkEvent.serviceAccountEmail = endpoint.eventTrigger.serviceAccount;
        }
        if (endpoint.eventTrigger.region) {
            bkEvent.region = resolveString(endpoint.eventTrigger.region);
        }
        trigger = { eventTrigger: bkEvent };
    }
    else if ("scheduleTrigger" in endpoint) {
        const bkSchedule = {
            schedule: resolveString(endpoint.scheduleTrigger.schedule),
            timeZone: resolveString(endpoint.scheduleTrigger.timeZone),
        };
        const bkRetry = {};
        if (endpoint.scheduleTrigger.retryConfig.maxBackoffSeconds) {
            bkRetry.maxBackoffDuration = proto.durationFromSeconds(resolveInt(endpoint.scheduleTrigger.retryConfig.maxBackoffSeconds));
        }
        if (endpoint.scheduleTrigger.retryConfig.minBackoffSeconds) {
            bkRetry.minBackoffDuration = proto.durationFromSeconds(resolveInt(endpoint.scheduleTrigger.retryConfig.minBackoffSeconds));
        }
        if (endpoint.scheduleTrigger.retryConfig.maxRetrySeconds) {
            bkRetry.maxRetryDuration = proto.durationFromSeconds(resolveInt(endpoint.scheduleTrigger.retryConfig.maxRetrySeconds));
        }
        proto.copyIfPresent(bkRetry, endpoint.scheduleTrigger.retryConfig, "retryCount", "maxDoublings");
        bkSchedule.retryConfig = bkRetry;
        trigger = { scheduleTrigger: bkSchedule };
    }
    else if ("taskQueueTrigger" in endpoint) {
        const bkTaskQueue = {};
        if (endpoint.taskQueueTrigger.rateLimits) {
            const bkRateLimits = {};
            proto.renameIfPresent(bkRateLimits, endpoint.taskQueueTrigger.rateLimits, "maxConcurrentDispatches", "maxConcurrentDispatches", resolveInt);
            proto.renameIfPresent(bkRateLimits, endpoint.taskQueueTrigger.rateLimits, "maxDispatchesPerSecond", "maxDispatchesPerSecond", resolveInt);
            bkTaskQueue.rateLimits = bkRateLimits;
        }
        if (endpoint.taskQueueTrigger.retryConfig) {
            const bkRetryConfig = {};
            proto.renameIfPresent(bkRetryConfig, endpoint.taskQueueTrigger.retryConfig, "maxAttempts", "maxAttempts", resolveInt);
            proto.renameIfPresent(bkRetryConfig, endpoint.taskQueueTrigger.retryConfig, "maxBackoffSeconds", "maxBackoffSeconds", (from) => {
                return proto.durationFromSeconds(resolveInt(from));
            });
            proto.renameIfPresent(bkRetryConfig, endpoint.taskQueueTrigger.retryConfig, "minBackoffSeconds", "minBackoffSeconds", (from) => {
                return proto.durationFromSeconds(resolveInt(from));
            });
            proto.renameIfPresent(bkRetryConfig, endpoint.taskQueueTrigger.retryConfig, "maxRetrySeconds", "maxRetryDurationSeconds", (from) => {
                return proto.durationFromSeconds(resolveInt(from));
            });
            proto.renameIfPresent(bkRetryConfig, endpoint.taskQueueTrigger.retryConfig, "maxDoublings", "maxDoublings", resolveInt);
            bkTaskQueue.retryConfig = bkRetryConfig;
        }
        if (endpoint.taskQueueTrigger.invoker) {
            bkTaskQueue.invoker = endpoint.taskQueueTrigger.invoker.map((sa) => resolveString(sa));
        }
        trigger = { taskQueueTrigger: bkTaskQueue };
    }
    else {
        (0, functional_1.assertExhaustive)(endpoint);
    }
    return trigger;
}
